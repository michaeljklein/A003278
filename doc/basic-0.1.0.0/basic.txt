-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/githubuser/basic#readme</a>
@package basic
@version 0.1.0.0

module Lib

-- | First differences
diff :: Num a => [a] -> [a]

-- | Nest a function <tt>n</tt> times on the input
nest :: Int -> (a -> a) -> a -> a

-- | Finding cycles in series efficiently:
--   
--   <pre>
--   Make a map from values in the series to the initial offset of the value and the sizes of gaps between each value.
--     For example:
--       1,1,2,2,2,1,3,1,3,2,1,3,2,1,2,3
--     =&gt;
--       1 =&gt; (0, [0,3,1,2,2])
--       2 =&gt; (2, [0,0,4,2,1])
--       3 =&gt; (6, [1,2,3])
--   
--   First, note that there is a cycle containing x only if the sizes of the gaps between x's cycle (constant, i.e. one element cycles are valid).
--   
--   Next, note that if (x) cycles with period (p), and if the next (p-1) value after the initial (x) also cycle, with periods p1, p2, .. p(p0 - 1),
--                      then we may be able to combine the cycles into a single one.
--                      In particular, if all other periods divide p0, then it's valid.
--                      If any period is a multiple of p0, we need to continue checking for that period. e.g. if p0 = 2, p1 = 4, then they're compatible iff p3 is compatible with p0
--   
--   Since the map transformation results in strictly smaller cycle problems, we recurse on those problems to solve them in a similar way.
--     (with guaranteed termination)
--   
--   We can lazily construct the intermediate solutions recursively for all subproblems while traversing each series.
--   
--   The problem then becomes of how lazy evaluation affects the time performance, whether some subproblems can be parallelized, and whether there's a better performance order than on-demand.
--   
--   - This looks like comonads, especially the duplication and (co?) recursion
--   - We probably also want to store how long the current cycle has been going + how many values we've traversed.
--     This should allow computing cycles for any offset from the front at the same time.
--       (In the stack of gaps, we also store the number of previous equal, cycling values and their period).
--   
--   -- valuePositionDiffMap :: (Foldable t, Ord a) =&gt; t a -&gt; Map a (Int, [Int])
--   -- valuePositionDiffMap =
--   
--   valuePositionDiffMap :: Ord a =&gt; Fold a (Map a (Int, [Int]))
--   
--   valuePositionDiffMapM :: Ord a =&gt; FoldM (State (Map a (Int, [Int]))) a ()
--   </pre>
findingCyclesInSeries :: ()

-- | Strict <a>Int</a>-indexed values
data Indexed a
Indexed :: {-# UNPACK #-} !Int -> a -> Indexed a
[indexOf] :: Indexed a -> {-# UNPACK #-} !Int
[indexed] :: Indexed a -> a

-- | <a>uncurry</a> for <a>Indexed</a>
uncurryi :: (Int -> a -> b) -> Indexed a -> b

-- | <a>curry</a> for <a>Indexed</a>
curryi :: (Indexed a -> b) -> Int -> a -> b

-- | Convert an indexed fold to one that is not indexed, but also returns
--   the length of the input.
ifoldLen :: Fold (Indexed a) b -> Fold a (Indexed b)

-- | Convert an indexed monadic fold to one that is not indexed, but also
--   returns the length of the input.
ifoldLenM :: Monad m => FoldM m (Indexed a) b -> FoldM m a (Indexed b)

-- | Add an additional position to a position difference map
stepPositionDiffMap :: Ord a => Int -> a -> Map a (Indexed [Int]) -> Map a (Indexed [Int])

-- | Fold into a position difference map
positionDiffMap :: Ord a => Fold a (Indexed (Map a (Indexed [Int])))

-- | Position differences resulting from a series of <tt>a</tt>
newtype PosDiffs a
PosDiffs :: Map a (Indexed [Int]) -> PosDiffs a
[getPosDiffs] :: PosDiffs a -> Map a (Indexed [Int])

-- | <a>PosDiffs</a> specialized to integers
newtype IntPosDiffs
IntPosDiffs :: IntMap (Indexed [Int]) -> IntPosDiffs
[getIntPosDiffs] :: IntPosDiffs -> IntMap (Indexed [Int])

-- | po-cycles (partial-order cycles): the cycles of the comparisions
--   between successive elements.
partialOrderCycles :: ()

-- | Non-empty cycles, composed of an index of rotation and a rotated
--   state.
--   
--   <pre>
--   Operations are provided to:
--   - extract<i>build from index</i>state
--   - map over each
--   - rotations (succIxF, predIxF, seekIxF)
--   - relative indexing
--   
--   Example instances:
--   - cyclically indexed list, vector, etc.
--   - _
--   </pre>
class CycleIx (f :: *) a where {
    data family IxState f a :: *;
    data family IxF f a :: *;
}

-- | Half of an isomophism:
--   
--   <pre>
--   <a>uncurry</a> <a>toIxF</a> :: (<a>Int</a>, <a>IxState</a> f a) -&gt; <a>IxF</a> f a
--   <a>liftM2</a> (,) <a>ixF</a> <a>ixState</a> :: <a>IxF</a> f a -&gt; (<a>Int</a>, <a>IxState</a> f a)
--   </pre>
toIxF :: CycleIx f a => Int -> IxState f a -> IxF f a
ixF :: CycleIx f a => IxF f a -> Int
ixState :: CycleIx f a => IxF f a -> IxState f a
mapIxF :: CycleIx f a => (Int -> Int) -> IxF f a -> IxF f a
mapIxState :: CycleIx f a => (IxState f a -> IxState f a) -> IxF f a -> IxF f a
bimapIxF :: CycleIx f a => (Int -> Int) -> (IxState f a -> IxState f a) -> IxF f a -> IxF f a
succIxF :: CycleIx f a => IxF f a -> IxF f a
predIxF :: CycleIx f a => IxF f a -> IxF f a
seekIxF :: CycleIx f a => Int -> IxF f a -> IxF f a
headIxF :: CycleIx f a => IxF f a -> a
indexIxF :: CycleIx f a => Int -> IxF f a -> a
buildIxF :: CycleIx f a => a -> IxF f a
snocIxF :: CycleIx f a => a -> IxF f a -> IxF f a
foldableIxF :: (CycleIx f a, Foldable t) => t a -> Maybe (IxF f a)

-- | Non-empty sequences
data Seq1 a

-- | Non-empty sequences of <a>Int</a>s
data IntSeq1
data Cycled a
Cycled :: Map a ValueState -> IxF (Seq1 a) a -> Int -> Int -> Cycled a
[runCycled] :: Cycled a -> Map a ValueState
[cycle] :: Cycled a -> IxF (Seq1 a) a
[cycleLen] :: Cycled a -> Int
[cycleReps] :: Cycled a -> Int
data IntCycled
IntCycled :: IntMap ValueState -> IntSeq1 -> Int -> Int -> IntCycled
[runIntCycled] :: IntCycled -> IntMap ValueState
[currentCycle] :: IntCycled -> IntSeq1
[currentCycleLen] :: IntCycled -> Int
[currentCycleReps] :: IntCycled -> Int
data ValueState
ValueState :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> IntCycled -> ValueState
[firstPos] :: ValueState -> {-# UNPACK #-} !Int
[lastPos] :: ValueState -> {-# UNPACK #-} !Int
[locPositions] :: ValueState -> IntCycled

-- | <a>undefined</a>
stepCycled :: Ord a => Cycled a -> a -> Cycled a

-- | This is a first approximation of a division based "finite differences"
--   data type.
--   
--   It will need a way to handle division by zero better.
--   
--   <pre>
--    What about saying that the modulo must be in [0..modulus] for non-zero and [1..] for zero?
--    In addition, defining: 0 <a>div</a> 0 = 1?
--    Then: prevs, 0, positive, .. -&gt; (0, positive) : ..
--   
--    If 0/0 = 1
--      Then: prevs, 0, 0, .. -&gt; (1, 0) : ..
--   
--    If 0/0 = 0
--      Then: prevs, 0, 0, .. -&gt; (0, 0) : ..
--   
--   0/0 = 0 might be better.. it might be closer to "continuous"
--   </pre>
data ProdDiff a
ProdDiff :: [a] -> [(a, [a])] -> ProdDiff a
[prodDiffHead] :: ProdDiff a -> [a]
[prodDiffTail] :: ProdDiff a -> [(a, [a])]

-- | The next <a>ProdDiff</a> or <a>Nothing</a> if the head is empty
succProdDiffMaybe :: Integral a => ProdDiff a -> Maybe (ProdDiff a)

-- | <a>divMods</a> with known first value (so no <a>Maybe</a> and not
--   returned)
divMods1 :: Integral a => a -> [a] -> [(a, a)]

-- | <a>div</a>s and <a>mod</a>s of previous values, with an initial value,
--   or <a>Nothing</a> if the list is empty.
divMods :: Integral a => [a] -> Maybe (a, [(a, a)])

-- | The previous <a>ProdDiff</a> series or itself if the tail is empty
predProdDiff :: Num a => ProdDiff a -> ProdDiff a

-- | The previous <a>ProdDiff</a> series or <a>Nothing</a> if the tail is
--   empty
predProdDiffMaybe :: Num a => ProdDiff a -> Maybe (ProdDiff a)

-- | The previous <a>ProdDiff</a>, using the given list
predProdDiffWith :: Num a => a -> [a] -> [a] -> [a]

-- | Notes on arithmetic progressions
--   
--   <pre>
--   = zipWith (x mod' -&gt;
--   
--   as = [a0, a1, a2, a3, ..]
--   
--   divs = [a1 <a>div</a> a0, a2 <a>div</a> a1, a3 <a>div</a> a2, ..]
--   mods = [a1 <a>mod</a> a0, a2 <a>mod</a> a1, a3 <a>mod</a> a2, ..]
--   
--   as = [a0, a0 * d1 + mod1, % * d2 + mod2, % * d3 + mod3, ..]
--   
--   as :: Set (Positive Integer)
--   if sum [1 / a | a &lt;- as] == infinity
--   then
--   forall (n :: Natural).
--     exists (k :: N).
--       isArithmeticSeries [a !! (k + i) | i &lt;- [0..n]]
--   
--   in other words, if
--                     sum . fmap (1 /) == const infinity
--                   then
--                     there are arithmetic progressions of every length.
--   
--   For example, all elements are arithmetic progressions of length 1 and all pairs of elements are arithmetic progressions of length 2.
--   
--   </pre>
arithmeticProgressionNotes :: ()

-- | Get akk arithmetic progressions of all lengths
arithProgs :: (Num a, Eq a) => [a] -> [[a]]

-- | Check for arithmetic progressions of a given length
arithProgsLen :: (Num a, Eq a) => Int -> [a] -> [[a]]

-- | Is it an arithmetic progression?
isArithProg :: (Num a, Eq a) => [a] -> Bool

-- | <a>Just</a> if the predicate returns <a>True</a>
predMaybe :: (a -> Bool) -> a -> Maybe a

-- | <pre>
--   <a>succSeries</a> 2
--   </pre>
succPairs :: () => [a] -> [[a]]

-- | <a>takeExactly</a> <tt>n</tt> for every <a>tail</a> in <a>tails</a>
--   and drop <a>tails</a> with fewer values
succSeries :: Int -> [a] -> [[a]]

-- | Take exactly the given number of elements or return <a>Nothing</a>
takeExactly :: Int -> [a] -> Maybe [a]

-- | An infinite list of prime numbers, using a sieve method
primes :: [Integer]
data Universe
Universe :: {-# UNPACK #-} !Int -> !IntSet -> Universe
[maxVal] :: Universe -> {-# UNPACK #-} !Int
[series] :: Universe -> !IntSet

-- | Initial universe, with <tt><a>series</a> = [1]</tt>
initialUniverse :: Universe

-- | The next value in a <a>Universe</a>
nextVal :: Universe -> Int

-- | Is the next value valid?
--   
--   A value is invalid if its addition to the series would result in an
--   arithmetic progression of length 3.
validNextVal :: Universe -> Int -> Bool

-- | Add a value to the series, without checking whether it's valid
addNextVal :: Int -> Universe -> Universe

-- | Find and add the next value to the <a>Universe</a>
stepUniverse :: Universe -> Universe

-- | All <a>Universe</a>s, starting with the <a>initialUniverse</a>
universes :: [Universe]
someFunc2 :: IO ()
someFunc :: IO ()

-- | Extended idea:
--   
--   <pre>
--   Extend idea:
--   - Tree defined as:
--     step prevTree = traverse over complete trees, finding their minimal values
--       for each found, [found..] is a valid extension, forming the next layer of the tree.
--   
--   e.g. binary tree, minimal, minimal + 1.
--   
--   Maybe it's possible to derive the value from the path.
--   </pre>
extendedIdea :: ()

-- | Only keep one out of every <tt>n</tt>
onlyEvery :: Int -> [a] -> [a]

-- | Example with <a>mapMTimed_</a>
exampleMapMTimed_ :: IO ()

-- | <a>mapM_</a> where results are <a>timed</a> and the timing is printed
--   with the results
mapMTimed_ :: MonadIO m => (a -> m ()) -> [a] -> m ()

-- | Run a monadic action and return its duration
timed :: MonadIO m => m () -> m NominalDiffTime

-- | Third implementation
--   
--   <pre>
--   rec0 n = case divMod n 2 of
--              (n', 0) -&gt;
--   
--   a(2k + 2) = a(2k + 1) + 1, a(2^k + 1) = 2*a(2^k).
--   
--   it appears that (rec3 x <a>mod</a> 3^i) cycles with period 2^i.
--   
--   i.e.,
--     rec3 x <a>mod</a> 3^i == rec3 (mod x 2^i) <a>mod</a> 3^i
--   </pre>
rec3 :: Integer -> Integer

-- | Notes on the recursion:
--   
--   <pre>
--   3 * loop (n <a>div</a> 2) - (2 - mod n 2)
--   3 * loop (n <a>div</a> 2) - 2 + mod n 2
--   
--   3 * (3 * loop (n <a>div</a> 4) - 2 + mod (n <a>div</a> 2) 2) - 2 + mod n 2
--   9 * loop (n <a>div</a> 4) - 6 + 3 * mod (n <a>div</a> 2) - 2 + mod n 2
--   9 * loop (n <a>div</a> 4) - 8 + 3 * mod (n <a>div</a> 2) + mod n 2
--   
--   9 * (3 * loop (n <a>div</a> 8) - 2 + mod (n <a>div</a> 4)) - (3 * 2 + 2) + 3 * mod (n <a>div</a> 2) + mod n 2
--   27 * loop (n <a>div</a> 8) - 9 * 2 + 9 * mod (n <a>div</a> 4)) - (3 * 2 + 2) + 3 * mod (n <a>div</a> 2) + mod n 2
--   27 * loop (n <a>div</a> 8) - (9 * 2 + 3 * 2 + 2) + 9 * mod (n <a>div</a> 4) + 3 * mod (n <a>div</a> 2) + mod n 2
--   
--   3^i * loop (n <a>div</a> 2^i) - 2 * sum [3^j | j &lt;- [0..i-1]] + sum [3^j * mod (n <a>div</a> 2^j) | j &lt;- [0..i-1]]
--   
--   OK
--     So it looks like I screwed up the algebra somewhere, but otherwise the theory seems sound.
--     It looks like I might be able to travel from minBit to maxBit and multiply the 3's as I go instead of computing powers as well.
--   
--   This would result in a log2 time algorithm, with a couple additions, multiplications, bitshifts, etc. per bit.
--   
--   (1<i>a + 1</i>b)
--   (a + b) / (a * b)
--   (a <a>div</a> gcd a b + b <a>div</a> gcd a b) / lcm a b
--   
--   suppose:
--     n = sum [an j * 2^j | j &lt;- [0..m]]
--     where an m = 1
--   then
--     loop hits 0 at i = m
--     loop n = sum [3^j * mod (n <a>div</a> 2^j) | j &lt;- [0..i-1]] - 2 * sum [3^j | j &lt;- [0..i-1]]
--     loop n = sum [3^j * (2 - mod (n <a>div</a> 2^j) 2) | j &lt;- [0..i-1]]
--   
--     loop n = sum [3^j * mod (n <a>div</a> 2^j) | j &lt;- [0..i-1]] - 2 * ((3^(i - 1) - 1) / 2)
--     loop n = sum [3^j * mod (n <a>div</a> 2^j) | j &lt;- [0..i-1]] + 1 - 3^(i - 1)
--   
--   a(n)-1 in ternary = n-1 in binary
--   </pre>
notesOnRheRecursion :: ()

-- | Simple implementation of a memoization <a>Monad</a> transformer to
--   memoize a function of the type:
--   
--   <pre>
--   Int -&gt; Integer
--   </pre>
type MemoT = StateT (IntMap Integer)

-- | Run <a>MemoT</a> with no initially known values
--   
--   Return the result along with an <a>IntMap</a> containing all computed
--   values
runMemoT :: Monad m => MemoT m a -> m (a, IntMap Integer)

-- | <a>runMemoT</a> without the <a>IntMap</a> of results
evalMemoT :: Monad m => MemoT m a -> m a

-- | <a>rec3</a> memoized with <a>MemoT</a>
rec3M :: Monad m => Integer -> MemoT m Integer

-- | Conjecture on arithmetic progressions
--   
--   <pre>
--   conjecture:
--     if each arithmetic-progression free size has a lower bound of the above form, i.e. f n = k * f (div n (progressionSize - 1)) + line (mod n (progressionSize - 1))
--        then since each one forms a lower bound for the minimal series that's ..-free, it forms an uppwer bound for the sum of its reciprocals.
--          but since its guaranteed to be at least exponential..
--   
--   a(n) = b(n+1) with b(0)=1, b(2n)=3b(n)-2, b(2n+1)=3b(n)-1
--   </pre>
arithProgConjecture :: ()
instance GHC.Show.Show Lib.Universe
instance GHC.Classes.Ord Lib.Universe
instance GHC.Classes.Eq Lib.Universe
instance GHC.Generics.Generic1 Lib.Indexed
instance GHC.Generics.Generic (Lib.Indexed a)
instance GHC.Base.Functor Lib.Indexed
instance GHC.Read.Read a => GHC.Read.Read (Lib.Indexed a)
instance GHC.Show.Show a => GHC.Show.Show (Lib.Indexed a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Lib.Indexed a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Lib.Indexed a)
instance Data.Foldable.Foldable Lib.Indexed
instance Data.Traversable.Traversable Lib.Indexed
